# -*- coding: utf-8 -*-
"""WPI_Steel-Forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PesAScB7FCM3lr9cSw5FN_bOjE79z6HY
"""

# üì¶ Install required packages if not already installed
!pip install xgboost openpyxl

# üìö Imports
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from xgboost import XGBRegressor
import matplotlib.pyplot as plt

# üîΩ Load Excel file from specified path
file_path = "/content/WPI_Master-dataset.xlsx"
df = pd.read_excel(file_path)

# üßπ Rename and clean
df = df.rename(columns={
    'Date': 'Date',
    'WPI (stainless)': 'WPI_Stainless',
    'WPI (mild flat)': 'WPI_MildFlat',
    'WPI (mild long)': 'WPI_MildLong',
    'WPI (Crude Petroleum)': 'WPI_CrudePetroleum',
    'WPI (Iron Ore)': 'WPI_IronOre',
    'WPI (Coking Coal)': 'WPI_CokingCoal',
    'WPI (non-ferrous metals)': 'WPI_NonFerrous',
    '(IIP 24th col)': 'IIP_Metals',
    '(IIP 25th col)': 'IIP_Machinery',
    'Manufacturing PMI': 'Manufacturing_PMI',
    'Avg. USD/INR': 'USD_INR',
    'Inflation Rate (%)': 'InflationRate',
    'Crude Steel Prod (MnT)': 'CrudeSteel_MnT',
    'Finished Steel Prod (MnT)': 'FinishedSteel_MnT',
    'Import (MnT)': 'Import_MnT',
    'Export (MnT)': 'Export_MnT',
    'Consumption (MnT)': 'Consumption_MnT',
    '(SHFE)': 'SHFE',
    '(Mild Steel Futures)': 'MildSteelFutures',
    '(WPI cement)': 'WPI_Cement'
})
df['Date'] = pd.to_datetime(df['Date'])
df.set_index('Date', inplace=True)

# üéØ Targets and Features
targets = ['WPI_Stainless', 'WPI_MildFlat', 'WPI_MildLong']
features = [
    'USD_INR', 'Consumption_MnT', 'FinishedSteel_MnT',
    'CrudeSteel_MnT', 'Manufacturing_PMI', 'SHFE', 'MildSteelFutures',
    'WPI_CrudePetroleum', 'InflationRate', 'IIP_Machinery', 'Import_MnT',
    'Export_MnT', 'WPI_Cement'
]

# ‚ûï Add lag features
for col in features:
    df[f"{col}_lag1"] = df[col].shift(1)
df = df.dropna()

# üßÆ Prepare training data
X = df[[f"{col}_lag1" for col in features]]
y_stainless = df['WPI_Stainless']
y_mildflat = df['WPI_MildFlat']
y_mildlong = df['WPI_MildLong']

# üî¢ Standardize
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# ü§ñ Train XGBoost models
model_s = XGBRegressor(n_estimators=100, max_depth=3, learning_rate=0.1)
model_f = XGBRegressor(n_estimators=100, max_depth=3, learning_rate=0.1)
model_l = XGBRegressor(n_estimators=100, max_depth=3, learning_rate=0.1)
model_s.fit(X_scaled, y_stainless)
model_f.fit(X_scaled, y_mildflat)
model_l.fit(X_scaled, y_mildlong)

# ‚è≥ Forecast inputs from May 2025 to June 2026
future_dates = pd.date_range(start='2025-05-01', end='2026-06-01', freq='MS')
forecast_df = pd.DataFrame(index=future_dates)

for col in features:
    ts = df[col]
    trend_model = LinearRegression().fit(np.arange(len(ts)).reshape(-1, 1), ts.values)
    future_time = np.arange(len(ts), len(ts) + len(future_dates)).reshape(-1, 1)
    forecast_df[f"{col}_lag1"] = trend_model.predict(future_time)

# üî¢ Standardize future inputs
X_future = scaler.transform(forecast_df)

# üîÆ Forecast WPI values
forecast_stainless = model_s.predict(X_future)
forecast_mildflat = model_f.predict(X_future)
forecast_mildlong = model_l.predict(X_future)

# üìä Create result DataFrame
result_df = pd.DataFrame({
    'WPI_Stainless_Forecast': forecast_stainless,
    'WPI_MildFlat_Forecast': forecast_mildflat,
    'WPI_MildLong_Forecast': forecast_mildlong
}, index=future_dates)

# üìà Plotting
def plot_forecast(hist, forecast, label):
    plt.figure(figsize=(12, 6))
    plt.plot(hist, label="Historical")
    plt.plot(result_df.index, forecast, linestyle='--', label="Forecast")
    plt.title(f"{label} Forecast")
    plt.xlabel("Date")
    plt.ylabel("WPI")
    plt.legend()
    plt.grid(True)
    plt.show()

plot_forecast(df['WPI_Stainless'], result_df['WPI_Stainless_Forecast'], "WPI Stainless Steel")
plot_forecast(df['WPI_MildFlat'], result_df['WPI_MildFlat_Forecast'], "WPI Mild Flat")
plot_forecast(df['WPI_MildLong'], result_df['WPI_MildLong_Forecast'], "WPI Mild Long")

# üñ®Ô∏è Print WPI forecast table for May 2025 to May 2026
print("üìÖ WPI Forecasts (May 2025 to May 2026):")
display(result_df.round(2).head(13))

print(df.columns.tolist())

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX

# üìÖ Forecast settings
forecast_horizon = 13  # Months: May 2025 to May 2026
targets = ['WPI_Stainless', 'WPI_MildFlat', 'WPI_MildLong']

# üì¶ Dictionary to store forecasted values
sarima_forecasts = {}

# üîÆ Fit SARIMA and forecast each WPI
for col in targets:
    print(f"Training SARIMA model for {col}...")

    # Fit SARIMA (seasonal, monthly)
    model = SARIMAX(df[col], order=(1, 1, 1), seasonal_order=(0, 1, 1, 12))
    results = model.fit(disp=False)

    # Forecast next 13 months
    forecast = results.forecast(steps=forecast_horizon)
    sarima_forecasts[col] = forecast

# üìÖ Forecast index (starting from May 2025)
forecast_index = pd.date_range(start='2025-05-01', periods=forecast_horizon, freq='MS')

# üìä Combine into a DataFrame
sarima_result_df = pd.DataFrame(sarima_forecasts, index=forecast_index)

# üìã Print forecast table
# print("\nüìÖ SARIMA Forecast (May 2025 ‚Äì May 2026):")
# print(sarima_result_df.round(2))

# üìà Plotting function
def plot_sarima_series(series_name):
    plt.figure(figsize=(12, 5))
    plt.plot(df[series_name], label="Historical")
    plt.plot(sarima_result_df.index, sarima_result_df[series_name], linestyle='--', label="Forecast")
    plt.title(f"SARIMA Forecast for {series_name}")
    plt.xlabel("Date")
    plt.ylabel("WPI")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# üìà Plot all three
for col in targets:
    plot_sarima_series(col)

# üìã Print forecast table instead of plotting
print("\nüìÖ SARIMA Forecast Table (May 2025 ‚Äì May 2026):")
display(sarima_result_df.round(2).head(13))  # or use .to_string() for script

# üßæ Optional: save to Excel
# sarima_result_df.to_excel("SARIMA_WPI_Forecast.xlsx")

# üìõ Rename columns if not done already
sarima_result_df = sarima_result_df.rename(columns={
    'WPI_Stainless': 'SARIMA_WPI_Stainless',
    'WPI_MildFlat': 'SARIMA_WPI_MildFlat',
    'WPI_MildLong': 'SARIMA_WPI_MildLong'
})

result_df = result_df.rename(columns={
    'WPI_Stainless_Forecast': 'XGB_WPI_Stainless',
    'WPI_MildFlat_Forecast': 'XGB_WPI_MildFlat',
    'WPI_MildLong_Forecast': 'XGB_WPI_MildLong'
})

# Combine both into a single DataFrame
hybrid_df = pd.DataFrame(index=sarima_result_df.index)

# For each target, average SARIMA and XGBoost
hybrid_df['Hybrid_WPI_Stainless'] = (
    sarima_result_df['SARIMA_WPI_Stainless'] + result_df['XGB_WPI_Stainless']
) / 2

hybrid_df['Hybrid_WPI_MildFlat'] = (
    sarima_result_df['SARIMA_WPI_MildFlat'] + result_df['XGB_WPI_MildFlat']
) / 2

hybrid_df['Hybrid_WPI_MildLong'] = (
    sarima_result_df['SARIMA_WPI_MildLong'] + result_df['XGB_WPI_MildLong']
) / 2

def plot_hybrid(metric):
    plt.figure(figsize=(12, 5))
    plt.plot(df[metric], label='Historical')
    plt.plot(hybrid_df.index, hybrid_df[f'Hybrid_{metric}'], '--', label='Hybrid Forecast')
    plt.title(f"Hybrid Forecast for {metric}")
    plt.xlabel("Date")
    plt.ylabel("WPI")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Plot for all 3
for metric in ['WPI_Stainless', 'WPI_MildFlat', 'WPI_MildLong']:
    plot_hybrid(metric)

print("ü§ù Hybrid Forecasts (SARIMA + XGBoost Average):")
display(hybrid_df.round(2).head(13))

